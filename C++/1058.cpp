//问题描述：
//	批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。
//输入格式：
//	输入在第一行给出两个正整数N（ <= 1000）和M（ <= 100），分别是学生人数和多选题的个数。随后M行，每行顺次给出一道题的满分值（不超过5的正整数）、
//	选项个数（不少于2且不超过5的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母a开始顺次排列。各项间以1个空格分隔。
//	最后N行，每行给出一个学生的答题情况，其每题答案格式为“(选中的选项个数 选项1 ……)”，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。
//输出格式：
//	按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从1开始编号）。
//	如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出“Too simple”。
//输入样例：
//	3 4
//	3 4 2 a c
//	2 5 1 b
//	5 3 2 b c
//	1 5 4 a b d e
//	(2 a c) (2 b d) (2 a c) (3 a b e)
//	(2 a c) (1 b) (2 a b) (4 a b d e)
//	(2 b d) (1 e) (2 b c) (4 a b c d)
//输出样例：
//	3
//	6
//	5
//	2 2 3 4

#include <iostream>
#include <stdio.h>
#include <memory.h>
using namespace std;

typedef unsigned char UINT8;
typedef struct{
	char acResult[5];
	UINT8 uScore;
	UINT8 uOptionCount;
	UINT8 uResultCount;
} ExamQuestion;
//typedef struct{
//	char acAnswer[5];
//	UINT8 uAnswerCount;
//} ExamAnswer;

void CollectResult(int nCount, char*pResult);
int CheckResult(ExamQuestion& question, char*pAnswer, int nCount);
int main() {
	int nQuestionCount = 0, nExamineeCount = 0;
	cin >> nExamineeCount >> nQuestionCount;
	ExamQuestion* pExamQuestions = new ExamQuestion[nQuestionCount];
	int nTemp = 0;
	for (int i = 0; i < nQuestionCount; ++i) {
		cin >> nTemp; pExamQuestions[i].uScore = nTemp;
		cin >> nTemp; pExamQuestions[i].uOptionCount = nTemp;
		cin >> nTemp; pExamQuestions[i].uResultCount = nTemp;
		CollectResult(nTemp, pExamQuestions[i].acResult);
	}
	int nIndex = 0;
	int* pScores = new int[nExamineeCount];
	memset(pScores, 0, sizeof(int)*nExamineeCount);
	int* pDifficultyInfo = new int[nQuestionCount];
	memset(pDifficultyInfo, 0, sizeof(int)*nQuestionCount);
	//ExamAnswer* pExamAnswers = new ExamAnswer[nExamineeCount * nQuestionCount];
	int nAnswerCount = 0;
	int nMaxWrongTimes = 0;
	char acAnswer[5] = { 0 };
	char cTemp = '\0';
	for (int i = 0; i < nExamineeCount; ++i) {
		for (int j = 0; j < nQuestionCount; ++j) {
			//cin >> nTemp; pExamAnswers[nIndex].uAnswerCount = nTemp;
			//CollectResult(nTemp, pExamAnswers[nIndex].acAnswer);
			while ((cTemp = getchar()) != '(');
			cin >> nAnswerCount;
			CollectResult(nAnswerCount, acAnswer);
			if (nAnswerCount == pExamQuestions[j].uResultCount) {
				if (CheckResult(pExamQuestions[j], acAnswer, nAnswerCount) > 0){
					pScores[i] += pExamQuestions[j].uScore;
					continue;
				}
			}
			pDifficultyInfo[j] += 1;
			if (nMaxWrongTimes < pDifficultyInfo[j]){
				nMaxWrongTimes = pDifficultyInfo[j];
			}
		}
	}
	for (int i = 0; i < nExamineeCount; ++i) {
		cout << pScores[i] << '\n';
	}
	if (nMaxWrongTimes == 0) {
		cout << "Too simple";
	}
	else{
		cout << nMaxWrongTimes;
		for (int i = 0; i < nQuestionCount; ++i) {
			if (nMaxWrongTimes == pDifficultyInfo[i]) {
				cout << ' ' << i + 1;
			}
		}
	}
	cout << endl;
	delete[] pDifficultyInfo;
	delete[] pScores;
	//delete[] pExamAnswers;
	delete[] pExamQuestions;
	return 0;
}

void CollectResult(int nCount, char*pResult) {
	if (pResult == nullptr) {
		return;
	}
	int nIndex = 0;
	char cTemp = '\0';
	while ((cTemp = getchar()) != '\n'){
		if (cTemp != ' ') {
			pResult[nIndex++] = cTemp;
			if (nCount == nIndex) {
				break;
			}
		}
	}
}

int CheckResult(ExamQuestion& question, char*pAnswer, int nCount) {
	bool bRight = false;
	for (int i = 0; i < nCount; ++i) {
		bRight = false;
		for (int j = 0; j < question.uResultCount; ++j) {
			if (question.acResult[j] == pAnswer[i]) {
				bRight = true;
				break;
			}
		}
		if (!bRight) {
			break;
		}
	}
	return bRight ? nCount : 0;
}
